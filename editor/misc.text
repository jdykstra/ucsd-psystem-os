(*
 * UCSD PASCAL - Version I.5
 * Copyright (C) 1978, 1979 Regents of the University of California
 * All Rights Reserved
 *
 * Permission to use, copy, modify and distribute any part of UCSD
 * PASCAL solely authored by UC authors before June 1, 1979 for
 * educational, research and non-profit purposes, without fee, and
 * without a written agreement is hereby granted, provided that the
 * above copyright notice, this paragraph and the following three
 * paragraphs appear in all copies.
 *
 * Those desiring to incorporate UCSD PASCAL into commercial products or
 * use for commercial purposes should contact the Technology Transfer &
 * Intellectual Property Services, University of California, San Diego,
 * 9500 Gilman Drive, Mail Code 0910, La Jolla, CA 92093-0910,
 * Ph: (858) 534-5815, Fax: (858) 534-7345, E-Mail: invent@ucsd.edu.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
 * INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF UCSD PASCAL, EVEN IF
 * THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 * THE SOFTWARE PROVIDED HEREIN IS ON AN "AS IS" BASIS, AND THE UNIVERSITY
 * OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS. THE UNIVERSITY OF CALIFORNIA
 * MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES OF ANY KIND,
 * EITHER IMPLIED OR EXPRESS, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR
 * THAT THE USE OF UCSD PASCAL WILL NOT INFRINGE ANY PATENT, TRADEMARK OR
 * OTHER RIGHTS.
 *
 * Case Number: SD1991-807 (2006)
 * http://invent.ucsd.edu/technology/cases/1995-prior/SD1991-807.shtml
 *)

FUNCTION MIN(* (A,B:INTEGER):INTEGER *);
BEGIN
  IF A<B THEN MIN:=A ELSE MIN:=B
END;

FUNCTION MAX (*(A,B:INTEGER):INTEGER*);
BEGIN
  IF A>B THEN MAX:=A ELSE MAX:=B
END;

FUNCTION GETCH(*:CHAR*);
VAR GCH: CHAR;
BEGIN
  READ(KEYBOARD,GCH);
  IF EOLN(KEYBOARD) THEN GCH:=CHR(EOL);
  GETCH:=GCH;
END;

PROCEDURE CONTROL(*(WHAT: SCREENCOMMAND)*);
BEGIN
  WITH SCREEN DO
    BEGIN
      IF HASPREFIX[WHAT] THEN WRITE(PREFIX);
      WRITE(CH[WHAT]);
      WRITE(FILLIT); {So that the slower terminals can keep up<--M. Bernard}
    END
END;

FUNCTION SCREENHAS(*(WHAT: SCREENCOMMAND): BOOLEAN*);
BEGIN
  SCREENHAS:=SCREEN.CH[WHAT]<>CHR(0);
END;

FUNCTION HASKEY(*(WHAT: KEYCOMMAND): BOOLEAN*);
BEGIN
  HASKEY:=KEYBRD.CH[WHAT] <> CHR(0);
END;

FUNCTION MAPCRTCOMMAND(VAR KCH:CHAR): KEYCOMMAND;
VAR WHATITIS: KEYCOMMAND;
    PREFIXREAD: BOOLEAN;
BEGIN
  WITH KEYBRD DO
  BEGIN
    IF (KCH=PREFIX) AND (PREFIX <> CHR(0)) THEN
      BEGIN
        PREFIXREAD:=TRUE;
        READ(KEYBOARD,KCH);
      END
    ELSE
      PREFIXREAD:=FALSE;
    WHATITIS:=BACKSPACEKEY;
    WHILE (WHATITIS <> NOTLEGAL) AND NOT((CH[WHATITIS]=KCH) AND
          (PREFIXREAD=HASPREFIX[WHATITIS])) DO
      WHATITIS:=SUCC(WHATITIS);
    MAPCRTCOMMAND:=WHATITIS;
  END;
END;

FUNCTION MAPTOCOMMAND(* (CH:CHAR): COMMANDS *);
(* For now, only the vector keys go through the new keyboard record *)
VAR KCMD: KEYCOMMAND;
BEGIN
  IF (CH=KEYBRD.PREFIX) AND (CH<>CHR(0)) THEN
    BEGIN
      KCMD:=MAPCRTCOMMAND(CH);
      IF KCMD IN [UPKEY..RIGHTKEY] THEN
        CASE KCMD OF
          UPKEY:    MAPTOCOMMAND:=UP;
          DOWNKEY:  MAPTOCOMMAND:=DOWN;
          LEFTKEY:  MAPTOCOMMAND:=LEFT;
          RIGHTKEY: MAPTOCOMMAND:=RIGHT
        END
    END
  ELSE
    MAPTOCOMMAND:=TRANSLATE[CH]
END;

FUNCTION UCLC(*(CH:CHAR):CHAR*); (* Map Lower Case to Upper Case *)
BEGIN
  IF CH IN ['a'..'z'] THEN UCLC:=CHR(ORD(CH)-32) ELSE UCLC:=CH
END;

PROCEDURE PROMPT;
BEGIN
  PROMPTLINE[1]:=DIRECTION;
  SAVETOP:=PROMPTLINE;
  CONTROL(WHOME);
  CLEARLINE(0);
  WRITE(PROMPTLINE)
END;

PROCEDURE CLEARSCREEN;
VAR I:INTEGER;
BEGIN
  IF SCREENHAS(CLEARSCN) THEN
    CONTROL(CLEARSCN)
  ELSE
    BEGIN
      HOME;
      ERASEOS(0,0)
    END;
END;

PROCEDURE CLEARLINE(*Y:INTEGER*);
VAR I: INTEGER;
BEGIN
  IF SCREENHAS(CLEARLNE) THEN
    CONTROL(CLEARLNE)
  ELSE
    BEGIN
      GOTOXY(0,Y);
      ERASETOEOL(0,Y);
    END;
END;

PROCEDURE PUTMSG;
BEGIN
  CONTROL(WHOME);
  CLEARLINE(0);
  SAVETOP:=MSG;
  WRITE(MSG);
END;

PROCEDURE HOME;
BEGIN
  IF SCREENHAS(WHOME) THEN
    CONTROL(WHOME)
  ELSE
    GOTOXY(0,0);
END;

PROCEDURE ERASETOEOL(*X,LINE:INTEGER*);
VAR I: INTEGER;
BEGIN
  IF SCREENHAS(ERASEEOL) THEN CONTROL(ERASEEOL)
  ELSE
    BEGIN
      IF LINE=SCREENHEIGHT THEN UNITWRITE(2,BLANKAREA,SCREENWIDTH-X)
      ELSE UNITWRITE(2,BLANKAREA,SCREENWIDTH-X+1);
      GOTOXY(X,LINE)
    END;
END;

PROCEDURE BLANKCRT(*Y: INTEGER*);
BEGIN
  IF SCREENHAS(ERASEEOS) THEN BEGIN GOTOXY(0,Y); CONTROL(ERASEEOS) END
  ELSE
    IF Y=1 THEN
      BEGIN
        CLEARSCREEN;
        WRITELN(SAVETOP)
      END
    ELSE
      BEGIN
        GOTOXY(0,Y);
        ERASEOS(0,Y);
      END;
END;

PROCEDURE ERASEOS(*X,LINE*);
VAR I: INTEGER;
BEGIN
  IF SCREENHAS(ERASEEOS) THEN
    CONTROL(ERASEEOS)
  ELSE
    BEGIN
      ERASETOEOL(X,LINE);
      FOR I:=LINE+1 TO SCREENHEIGHT DO BEGIN WRITELN; CLEARLINE(I) END;
      GOTOXY(X,LINE);
    END;
END;

PROCEDURE ERRWAIT;
BEGIN
  WRITE(CHR(BELL));
  PROMPT;
END;


PROCEDURE ERROR(*S: STRING;HOWBAD: ERRORTYPE*);
BEGIN
  UNITCLEAR(1); (* Throw away all characters queued up *)
  IF HOWBAD=FATAL THEN
    BLANKCRT(1)
  ELSE
    BEGIN HOME; CLEARLINE(0) END;
  WRITE('ERROR: ',S);
  IF HOWBAD=FATAL THEN
    EXIT(EDITOR)
  ELSE
    BEGIN
      WRITE('  Please press <spacebar> to continue.');
      REPEAT UNTIL GETCH=' '; NEEDPROMPT:=TRUE
    END;
END;

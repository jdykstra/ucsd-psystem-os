(*
 * UCSD PASCAL - Version I.5
 * Copyright (C) 1978, 1979 Regents of the University of California
 * All Rights Reserved
 *
 * Permission to use, copy, modify and distribute any part of UCSD
 * PASCAL solely authored by UC authors before June 1, 1979 for
 * educational, research and non-profit purposes, without fee, and
 * without a written agreement is hereby granted, provided that the
 * above copyright notice, this paragraph and the following three
 * paragraphs appear in all copies.
 *
 * Those desiring to incorporate UCSD PASCAL into commercial products or
 * use for commercial purposes should contact the Technology Transfer &
 * Intellectual Property Services, University of California, San Diego,
 * 9500 Gilman Drive, Mail Code 0910, La Jolla, CA 92093-0910,
 * Ph: (858) 534-5815, Fax: (858) 534-7345, E-Mail: invent@ucsd.edu.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
 * INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF UCSD PASCAL, EVEN IF
 * THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 * THE SOFTWARE PROVIDED HEREIN IS ON AN "AS IS" BASIS, AND THE UNIVERSITY
 * OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS. THE UNIVERSITY OF CALIFORNIA
 * MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES OF ANY KIND,
 * EITHER IMPLIED OR EXPRESS, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR
 * THAT THE USE OF UCSD PASCAL WILL NOT INFRINGE ANY PATENT, TRADEMARK OR
 * OTHER RIGHTS.
 *
 * Case Number: SD1991-807 (2006)
 * http://invent.ucsd.edu/technology/cases/1995-prior/SD1991-807.shtml
 *)

(*
 * Source: http://bitsavers.org/bits/UCSD_Pascal/ucsd_II.0/
 *     U123.1_Z80_ASSEM_SOURCE.raw.gz
 * Date: 1979-Apr-13
 *)

                {start of EXTRA.Z80.TEXT}
        {Copyright (c) 1978 Regents of University of California}

PROCEDURE INSTRCLASS;

PROCEDURE OPERROR;
BEGIN
  ERROR(76{Incorrect operand format});
  PUTBYTE(NOP);
END;

PROCEDURE OPENPARSE;
BEGIN
  IF SPCIALSTKINDEX<>-1 THEN
    BEGIN
      IF SPECIALSTK[SPCIALSTKINDEX]<>OPENPAREN THEN
        ERROR(80{( expected});
      SPCIALSTKINDEX:=SPCIALSTKINDEX-1;
      LEX;
      IF SYM^.ATTRIBUTE=DEFABS THEN
        BEGIN
          PUTBYTE(SYM^.VALUE);
          PUTBYTE(OPBYTE.GOODBYTE);
          LEX;
          IF LEXTOKEN<>PLUS THEN ERROR(79);
          IF EXPRESS(TRUE) THEN
            IF CHECKOPERAND(FALSE,TRUE,TRUE,0,255) THEN
              PUTBYTE(RESULT.OFFSETORVALUE);
          IF SPCIALSTKINDEX=-1 THEN
            ERROR(77)
          ELSE SPCIALSTKINDEX:=SPCIALSTKINDEX-1;
        END
      ELSE IF SYM^.NAME='HL      ' THEN
        BEGIN
          PUTBYTE(OPBYTE.GOODBYTE);
          LEX;
          IF LEXTOKEN<>CLOSEPAREN THEN ERROR(77);
          LEX;
        END
      ELSE
        BEGIN
          OPERROR;
          LEX;
        END
    END
  ELSE
    BEGIN
      OPERROR;
      LEX;
    END;
END;

PROCEDURE ZOP1;
{ PUSH POP }
BEGIN
  IF DEBUG THEN WRITELN('Op1');
  OPBYTE.GOODBYTE:=SYM^.VALUE;
  LEX;
  IF (SYM^.ATTRIBUTE=DEFRP) AND (SYM^.NAME<>'SP      ') THEN
    OPBYTE.RP:=SYM^.VALUE
  ELSE IF SYM^.ATTRIBUTE=DEFABS THEN
    PUTBYTE(SYM^.VALUE)
  ELSE OPERROR;
  PUTBYTE(OPBYTE.GOODBYTE);
  LEX;
END;

PROCEDURE ZOP2;
{ EX }
BEGIN
  IF DEBUG THEN WRITELN('Op2');
  OPBYTE.GOODBYTE:=SYM^.VALUE;
  LEX;
  IF LEXTOKEN=OPENPAREN THEN
    BEGIN
      LEX;
      IF SYM^.NAME<>'SP      ' THEN ERROR(81{SP expected});
      LEX;
      IF LEXTOKEN<>CLOSEPAREN THEN ERROR(77);
      LEX;
      IF LEXTOKEN<>COMMA THEN ERROR(78);
      LEX;
      IF SYM^.NAME='HL      ' THEN
        PUTBYTE(OPBYTE.GOODBYTE)
      ELSE IF SYM^.ATTRIBUTE=DEFABS THEN
        BEGIN
          PUTBYTE(SYM^.VALUE);
          PUTBYTE(OPBYTE.GOODBYTE);
        END
      ELSE OPERROR;
    END
  ELSE IF SYM^.NAME='DE      ' THEN
    BEGIN
      PUTBYTE(235);{DE,HL gives EB}
      LEX;
      IF LEXTOKEN<>COMMA THEN ERROR(78);
      LEX;
      IF SYM^.NAME<>'HL      ' THEN ERROR(82{HL expected});
    END
  ELSE IF SYM^.NAME='AF      ' THEN
    PUTBYTE(8) {AF,AF' gives 08}
  ELSE OPERROR;
  LEX;
END;

PROCEDURE ZOP3;
VAR  EXTRA:BYTESWAP;
     EXTRASYM:SYMTABLEPTR;
{ ADD }
BEGIN
  IF DEBUG THEN WRITELN('Op3');
  OPBYTE.BWORD:=SYM^.VALUE;
  LEX;
  IF SYM^.NAME='A       ' THEN
    BEGIN
      LEX;
      IF LEXTOKEN<>COMMA THEN ERROR(78);
      IF EXPRESS(TRUE) THEN
        BEGIN
          IF RESULT.ATTRIBUTE=DEFREG THEN
            BEGIN
              OPBYTE.SOURCE:=RESULT.OFFSETORVALUE;
              PUTBYTE(OPBYTE.GOODBYTE);
            END
          ELSE IF CHECKOPERAND(TRUE,TRUE,TRUE,-128,255) THEN
            BEGIN
              PUTBYTE(198);{A,n gives C6}
              EXTRA.GOODBYTE:=RESULT.OFFSETORVALUE;
              PUTBYTE(EXTRA.GOODBYTE);
            END
        END
      ELSE OPENPARSE;
    END
  ELSE IF SYM^.NAME='HL      ' THEN
    BEGIN
      OPBYTE.GOODBYTE:=OPBYTE.BADBYTE;
      LEX;
      IF LEXTOKEN<>COMMA THEN ERROR(78);
      LEX;
      IF (SYM^.ATTRIBUTE=DEFRP) AND (SYM^.NAME<>'AF      ') THEN
        OPBYTE.RP:=SYM^.VALUE
      ELSE OPERROR;
      PUTBYTE(OPBYTE.GOODBYTE);
      LEX;
    END
  ELSE IF SYM^.ATTRIBUTE=DEFABS THEN
    BEGIN
      EXTRASYM:=SYM;
      PUTBYTE(SYM^.VALUE);
      OPBYTE.GOODBYTE:=OPBYTE.BADBYTE;
      LEX;
      IF LEXTOKEN<>COMMA THEN ERROR(78);
      LEX;
      IF (SYM^.ATTRIBUTE=DEFRP) AND (SYM^.NAME<>'HL      ')
        AND (SYM^.NAME<>'AF      ') THEN
          OPBYTE.RP:=SYM^.VALUE
      ELSE IF SYM=EXTRASYM THEN
        OPBYTE.RP:=2
      ELSE OPERROR;
      PUTBYTE(OPBYTE.GOODBYTE);
      LEX;
    END
  ELSE OPERROR;
END;

PROCEDURE ZOP4;
{ ADC SBC }
BEGIN
  IF DEBUG THEN WRITELN('Op4');
  OPBYTE.BWORD:=SYM^.VALUE;
  LEX;
  IF SYM^.NAME='A       ' THEN
    BEGIN
      LEX;
      IF LEXTOKEN<>COMMA THEN ERROR(78);
      IF EXPRESS(TRUE) THEN
        BEGIN
          IF RESULT.ATTRIBUTE=DEFREG THEN
            BEGIN
              OPBYTE.SOURCE:=RESULT.OFFSETORVALUE;
              PUTBYTE(OPBYTE.GOODBYTE);
            END
          ELSE IF CHECKOPERAND(TRUE,TRUE,TRUE,0,255) THEN
            BEGIN
              OPBYTE.GOODBYTE:=OPBYTE.GOODBYTE + 64;{bit 7 goes on}
              PUTBYTE(OPBYTE.GOODBYTE);
              PUTBYTE(RESULT.OFFSETORVALUE);
            END;
        END
      ELSE OPENPARSE;
    END
  ELSE IF SYM^.NAME='HL      ' THEN
    BEGIN
      PUTBYTE(237); {HL,RP gives ED}
      OPBYTE.GOODBYTE:=OPBYTE.BADBYTE;
      LEX;
      IF LEXTOKEN<>COMMA THEN ERROR(78);
      LEX;
      IF (SYM^.ATTRIBUTE=DEFRP) AND (SYM^.NAME<>'AF      ') THEN
        OPBYTE.RP:=SYM^.VALUE
      ELSE OPERROR;
      PUTBYTE(OPBYTE.GOODBYTE);
      LEX;
    END
  ELSE OPERROR;
END;

PROCEDURE ZOP5;
{ SUB AND OR XOR CP }
BEGIN
  IF DEBUG THEN WRITELN('Op5');
  OPBYTE.GOODBYTE:=SYM^.VALUE;
  IF EXPRESS(TRUE) THEN
    BEGIN
      IF RESULT.ATTRIBUTE=DEFREG THEN
        BEGIN
          OPBYTE.SOURCE:=RESULT.OFFSETORVALUE;
          PUTBYTE(OPBYTE.GOODBYTE);
        END
      ELSE IF CHECKOPERAND(TRUE,TRUE,TRUE,-128,255) THEN
        BEGIN
          OPBYTE.GOODBYTE:=OPBYTE.GOODBYTE + 64;{bit 7 goes on}
          PUTBYTE(OPBYTE.GOODBYTE);
          OPBYTE.GOODBYTE:=RESULT.OFFSETORVALUE;
          PUTBYTE(OPBYTE.GOODBYTE);
        END
    END
  ELSE OPENPARSE;
END;

PROCEDURE ZOP6;
{ INC DEC }
BEGIN
  IF DEBUG THEN WRITELN('Op6');
  OPBYTE.BWORD:=SYM^.VALUE;
  IF EXPRESS(TRUE) THEN
    BEGIN
      IF RESULT.ATTRIBUTE=DEFABS THEN
        BEGIN
          PUTBYTE(RESULT.OFFSETORVALUE);
          PUTBYTE(OPBYTE.BADBYTE);
        END
      ELSE IF (RESULT.ATTRIBUTE=DEFRP) AND (SYM^.NAME<>'AF      ') THEN
        BEGIN
          OPBYTE.GOODBYTE:=OPBYTE.BADBYTE;
          OPBYTE.RP:=RESULT.OFFSETORVALUE;
          PUTBYTE(OPBYTE.GOODBYTE);
        END
      ELSE IF RESULT.ATTRIBUTE=DEFREG THEN
        BEGIN
          OPBYTE.DEST:=RESULT.OFFSETORVALUE;
          PUTBYTE(OPBYTE.GOODBYTE);
        END
      ELSE OPERROR;
    END
  ELSE OPENPARSE;
END;

PROCEDURE ZOP7;
{ RLC RL RRC RR SLA SRA SRL }
BEGIN
  IF DEBUG THEN WRITELN('Op7');
  OPBYTE.BWORD:=SYM^.VALUE;
  IF EXPRESS(TRUE) THEN
    BEGIN
      IF RESULT.ATTRIBUTE=DEFREG THEN
        BEGIN
          PUTBYTE(OPBYTE.GOODBYTE);
          OPBYTE.GOODBYTE:=OPBYTE.BADBYTE;
          OPBYTE.SOURCE:=RESULT.OFFSETORVALUE;
          PUTBYTE(OPBYTE.GOODBYTE);
        END
      ELSE OPERROR;
    END
  ELSE
    BEGIN
      OPENPARSE;
      PUTBYTE(OPBYTE.BADBYTE);
    END;
END;

PROCEDURE ZOP8;
{ BIT SET RES }
VAR   SAVE:INTEGER;
BEGIN
  IF DEBUG THEN WRITELN('Op8');
  OPBYTE.BWORD:=SYM^.VALUE;
  IF EXPRESS(TRUE) THEN
    IF CHECKOPERAND(TRUE,TRUE,TRUE,0,7) THEN
      SAVE:=RESULT.OFFSETORVALUE;
  IF EXPRESS(TRUE) THEN
    BEGIN
      IF RESULT.ATTRIBUTE=DEFREG THEN
        BEGIN
          PUTBYTE(OPBYTE.GOODBYTE);
          OPBYTE.GOODBYTE:=OPBYTE.BADBYTE;
          OPBYTE.SOURCE:=RESULT.OFFSETORVALUE;
        END
      ELSE OPERROR;
    END
  ELSE
    BEGIN
      OPENPARSE;
      OPBYTE.GOODBYTE:=OPBYTE.BADBYTE;
    END;
  OPBYTE.DEST:=SAVE;
  PUTBYTE(OPBYTE.GOODBYTE);
END;

PROCEDURE ZOP9;
{ JP }
BEGIN
  IF DEBUG THEN WRITELN('Op9');
  OPBYTE.BWORD:=SYM^.VALUE;
  IF EXPRESS(TRUE) THEN
    BEGIN
      IF RESULT.ATTRIBUTE=DEFCC THEN
        BEGIN
          OPBYTE.GOODBYTE:=194; {cc,nn gives 11xxx010=C2}
          OPBYTE.DEST:=RESULT.OFFSETORVALUE;
          PUTBYTE(OPBYTE.GOODBYTE);
          IF EXPRESS(TRUE) THEN
            PUTWORD(RESULT.OFFSETORVALUE);
        END
      ELSE IF (RESULT.ATTRIBUTE=DEFREG) AND (RESULT.OFFSETORVALUE=1) THEN
        BEGIN
          OPBYTE.GOODBYTE:=194; {cc,nn gives 11xxx010=C2}
          OPBYTE.DEST:=3;
          PUTBYTE(OPBYTE.GOODBYTE);
          IF EXPRESS(TRUE) THEN
            PUTWORD(RESULT.OFFSETORVALUE);
        END
      ELSE
        BEGIN
          PUTBYTE(OPBYTE.BADBYTE);
          PUTWORD(RESULT.OFFSETORVALUE);
        END;
    END
  ELSE
    BEGIN
      IF SPECIALSTK[SPCIALSTKINDEX]<>OPENPAREN THEN
        ERROR(80{( expected})
      ELSE
        SPCIALSTKINDEX:=SPCIALSTKINDEX-1;
      IF EXPRESS(TRUE) THEN
        IF RESULT.ATTRIBUTE=DEFABS THEN
          BEGIN
            PUTBYTE(SYM^.VALUE);
            PUTBYTE(OPBYTE.GOODBYTE);
          END
        ELSE IF (RESULT.ATTRIBUTE=DEFRP) AND (RESULT.OFFSETORVALUE=2) THEN
          BEGIN
            PUTBYTE(OPBYTE.GOODBYTE);
          END
        ELSE OPERROR;
      IF SPECIALSTK[SPCIALSTKINDEX]<>CLOSEPAREN THEN
        ERROR(77)
      ELSE SPCIALSTKINDEX:=SPCIALSTKINDEX-1;
    END;
END;

PROCEDURE ZOP10;
{ DJNZ }
BEGIN
  IF DEBUG THEN WRITELN('Op10');
  OPBYTE.BWORD:=SYM^.VALUE;
  IF EXPRESS(TRUE) THEN
    BEGIN
      RELOCATE.OFFSETORVALUE:=RELOCATE.OFFSETORVALUE - 2;
      PUTRELWORD(OPBYTE.BWORD,TRUE,FALSE);
    END
  ELSE PUTBYTE(NOP);
END;

(*
 * UCSD PASCAL - Version I.5
 * Copyright (C) 1978, 1979 Regents of the University of California
 * All Rights Reserved
 *
 * Permission to use, copy, modify and distribute any part of UCSD
 * PASCAL solely authored by UC authors before June 1, 1979 for
 * educational, research and non-profit purposes, without fee, and
 * without a written agreement is hereby granted, provided that the
 * above copyright notice, this paragraph and the following three
 * paragraphs appear in all copies.
 *
 * Those desiring to incorporate UCSD PASCAL into commercial products or
 * use for commercial purposes should contact the Technology Transfer &
 * Intellectual Property Services, University of California, San Diego,
 * 9500 Gilman Drive, Mail Code 0910, La Jolla, CA 92093-0910,
 * Ph: (858) 534-5815, Fax: (858) 534-7345, E-Mail: invent@ucsd.edu.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
 * INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF UCSD PASCAL, EVEN IF
 * THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 * THE SOFTWARE PROVIDED HEREIN IS ON AN "AS IS" BASIS, AND THE UNIVERSITY
 * OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS. THE UNIVERSITY OF CALIFORNIA
 * MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES OF ANY KIND,
 * EITHER IMPLIED OR EXPRESS, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR
 * THAT THE USE OF UCSD PASCAL WILL NOT INFRINGE ANY PATENT, TRADEMARK OR
 * OTHER RIGHTS.
 *
 * Case Number: SD1991-807 (2006)
 * http://invent.ucsd.edu/technology/cases/1995-prior/SD1991-807.shtml
 *)

(*
 * Source: http://bitsavers.org/bits/UCSD_Pascal/ucsd_II.0/
 *     U123.1_Z80_ASSEM_SOURCE.raw.gz
 * Date: 1979-Apr-13
 *)

                         {start of ASM1}
     {Copyright (c) 1978 Regents of the University of California}

TOKENS=(EQUAL,NOTEQUAL,BITWISEOR,EXCLUSIVEOR,DIVIDE,MODULO,ONESCOMPLEMENT,TNOT,
       OPENPAREN,CLOSEPAREN,OPENBRACKET,CLOSEBRACKET,OPNBRACE,CLSBRACE,
       COMMA,OPNBROKEN,CLSBROKEN,QUERY,PLUS,MINUS,
       ASTERISK,AMPERSAND,ATSIGN,COLON,NUMBERSIGN,AUTOINCR,AUTODECR,LOCCTR,
       FIRSTOPCODE,
       ASCII,ASECT,PSECT,ORG,INSTR,ALIGN,BLOCK,WORD,BIGHT,ENDLINE,
       CONDEND,TELSE,TMLISTON,TMLISTOFF,TPLISTON,TPLISTOFF,TABSOLUTE,
       TINTERP,MACRODEF,CONDITION,EQU,REF,DEF,PUBLIC,PRIVATE,TCONST,
       LIST,NOLIST,TPAGE,TITLE,PROC,FUNC,TEND,
       LASTOPCODE,
       INCLUDE,TLABEL,LOCLABEL,TSTRING,CONSTANT,TIDENTIFIER,MACROEND,TNULL);
    CODETYPE=(A,P);
    SOURCETYPE=(MACROSOURCE,PARMSOURCE,FILESOURCE);
    ATRIBUTETYPE=(DEFABS,PROCS,
           OPS1,OPS2,OPS3,OPS4,OPS5,OPS6,OPS7,OPS8,OPS9,OPS10,OPS11,
           OPS12,OPS13,OPS14,OPS15,OPS16,OPS17,OPS18,OPS19,OPS20,
           DEFRP,DEFREG,DEFCC,DEFIR,DEFUNKNOWN,INTERPS,
           PUBLICS,CONSTS,PRIVATES,REFS,DEFS,FUNCS,ABS,LABELS,UNKNOWN,MACROS);
    MACROPTR=^MACROTYPE;
    MACROTYPE=PACKED ARRAY[0..MACROSIZE] OF CHAR;
    JTABPTR=^JTAB;
    JTAB=RECORD               {Used for linkinfo references}
       PCOFFSET:INTEGER;
       LAST:JTABPTR
     END;
    BKLABELPTR=^BACKLABEL;
    SYMTABLEPTR=^SYMBOLTABLE;
    SYMBOLTABLE=RECORD        {Symboltable entry}
       NAME:PACKNAME;
       LINK:SYMTABLEPTR;
       CASE ATTRIBUTE:ATRIBUTETYPE OF
         {OPS1,OPS2,OPS3,OPS4,OPS5,OPS6,OPS7,OPS8,OPS9,OPS10,
         OPS11,OPS12,OPS13,OPS14,OPS15,OPS16,OPS17,OPS18,OPS19,OPS20,
         DEFRP,DEFREG,DEFCC,DEFIR,}
                            DEFABS:(VALUE:INTEGER);
ABS,LABELS,DEFS,DEFUNKNOWN,UNKNOWN:(OFFSETORVALUE:INTEGER;
                                    FWDREF:BKLABELPTR);
                            MACROS:(MACRO:MACROPTR);
      PUBLICS,PRIVATES,REFS,CONSTS:(NREFS,NWORDS:INTEGER;
                                    LINKOFFSET:JTABPTR);
                       PROCS,FUNCS:(FUNCNUM,NPARAMS:INTEGER)
      END;
    TEMPTABLE=RECORD            {Temporary table entry}
         TEMPNAME:PACKNAME;
         DEFOFFSET:INTEGER;
         FWDREF:BKLABELPTR;
         TEMPATRIB:ATRIBUTETYPE
      END;
    RELTYPE=(LLREL,LABELREL,EXTERNREL,LCREL,NOTSET);
    RESULTREC=RECORD            {expression evaluator result record}
         ATTRIBUTE:ATRIBUTETYPE;
         OFFSETORVALUE:INTEGER;
      END;
    RELREC=RECORD               {current expression's relocation info}
         TIPE:RELTYPE;
         UNDEF:BOOLEAN;
         OFFSETORVALUE,TEMPLABEL:INTEGER;
         ATTRIBUTE:ATRIBUTETYPE;
         SYM:SYMTABLEPTR
      END;
    BACKLABEL=PACKED RECORD     {forward reference record}
         WORDLC,BYTESIZE:BOOLEAN;
         OFFSET,LC,VALUE:INTEGER;
         NEXT:BKLABELPTR
      END;
    JTABREC=ARRAY[0..6] OF INTEGER;     {for storage of relocation info}
    BUFFERTYPE=PACKED ARRAY[0..511] OF BITE;
    SCRATCHREC=RECORD            {scratch file for temporary storage}
         CLASS:INTEGER;
         CASE BOOLEAN OF
              TRUE:(JUMPS:JTABREC);
             FALSE:(FWDREF:BACKLABEL)
    END;

{----------------------------------------------------------------------}

VAR SYM:SYMTABLEPTR;      {pointer to current symboltable entry}
    LEXTOKEN:TOKENS;      {current token returned by LEX}
    OUTBLKNO,             {next output block #}
    TEXTINDEX,            {index into TEXTLINE, containing line of source text}
    MACROINDEX,           {index into macro source sitting on heap}
    SPCIALSTKINDEX,       {index into stack of outstanding special symbols}
    CODECOUNT:INTEGER;    {index into array containing current line's code}
    OPBYTE:BYTESWAP;      {used exclusively by ZOP1 - ZOP20}
    CH:CHAR;
    DISPLAY:BOOLEAN;      {currently displaying output?}
    FULLLABEL:BKLABELPTR; {forward referenced labels still unresolved}
    RESULT:RESULTREC;     {result of last call to expression evaluator}

    BUFBOTTOM,            {start of BUFFER relative to start of output file}
    BUFFERPOS,            {next output byte relative to start of BUFFER}
    BUFFERTOP,            {next output byte relative to start of file}
    MAXBUFTOP,            {maximum BUFFERTOP}
    OUTBLKTOP,            {next block after current end of output file}
    PROCSTART,            {start of procedure relative to start of file}
    JCOUNT1,JCOUNT2,JCOUNT3,JCOUNT4, {indexes for relocation records JTABREC's}
    TEMPTOP,TEMPLABEL,TEMPBOTTOM,
    BLOCKPTR,BNUM,BLOCKNO,ALTBLOCNO,ALTBLOCPTR,
    PROCNUM,SEGSIZE,PAGENO,
    LINENUM,LISTNUM,
    NUMERRORS,
    OPVAL,CONSTVAL,
    PARMPTR,              {index into current PARM buffer}
    MCSTKINDEX,           {index into array of macro buffer pointers}
    SAVEMSX,              {MCSTKINDEX value when switching to PARMSOURCE}
    LINKEND,SCRATCHEND,CONDINDEX,
    LC,ALC,LASTLC,LOWLC,MINSPACE,MCLISTLEVEL,ENDOFPAGE  :INTEGER;

    SYMLAST,FOUND,CONSOLE,STARTLINE,FROMPUTWORD,NOTSTRING,LISTING,JUMPINFO,
    ADVANCE,PARMCHECK,ALTINPUT,EXPRSSADVANCE,DEFMCHOOK,BYTESEX,PATCHLIST,
    MACROLIST     :BOOLEAN;
    MCPTR:MACROPTR;
    BUFFER:^BUFFERTYPE;   {buffer for output code in core}
    LISTFILE:INTERACTIVE;
    CURFNAME,FIRSTFNAME:STRING[30];
    TITLELINE,STRVAL:STRING;
    TEXTLINE,BLANKLINE:PACKED ARRAY[0..101] OF CHAR;
    LINKNAME:STRING[15];

    RELOCATE,OPERAND1,OPERAND2,OPERAND3,NULLREL:RELREC;
    NEXTJP:JTABPTR;
    JUMP1,JUMP2,JUMP3,JUMP4:JTABREC;
    FREELABEL:BKLABELPTR;

    CURRENTATRIB:ATRIBUTETYPE;
    SOURCE:SOURCETYPE;
    CODESECTION:CODETYPE;
    MACROSTACK:ARRAY[0..MAXMACRO] OF MACROPTR; {stack of macro buffer pointers}
    PARMSTACK,                                 {stack of macro buffer indices}
    TEMPSTACK,                                 {legal TEMP stack range bottom}
    MCINDEX:ARRAY[0..MAXMACRO] OF INTEGER;     {stack of parm buffer positions}
    SPECIALSTK:ARRAY[0..MAXMACRO] OF TOKENS;
    TEMP:ARRAY[0..20] OF TEMPTABLE;
    HASH,HASHRES:ARRAY[0..HASHTOP] OF SYMTABLEPTR;
    LASTSYM:SYMTABLEPTR;

    ALTFILE:FILE;
    SCRATCH:FILE OF SCRATCHREC;

    KWORDS:ARRAY[0..NUMKWORDS] OF PACKNAME;
    KTOKEN:ARRAY [0..NUMKWORDS] OF TOKENS;
    XBLOCK:PACKED ARRAY[0..1023] OF CHAR;
    CONSTID,HEXCHAR:PACKED ARRAY[0..15] OF CHAR;
    CODE,BLANKCODE:PACKED ARRAY[0..CODESIZE] OF CHAR;
    HEAP:^INTEGER;
    SEGNAME,PROCNAME:PACKNAME;
    PROCTABLE:ARRAY[0..MAXPROC] OF INTEGER;


PROCEDURE ERROR(ERRORNUM:INTEGER); FORWARD;
FUNCTION  SWAPBYTE(WORD:INTEGER):INTEGER; FORWARD;
PROCEDURE PATCHCODE(FWDREF:BACKLABEL; BUFINDEX:INTEGER); FORWARD;
PROCEDURE IOCHECK(QUIT:BOOLEAN); FORWARD;
PROCEDURE LLCHECK; FORWARD;
PROCEDURE SCANLINE; FORWARD;
PROCEDURE LFCONSOLE; FORWARD;
PROCEDURE PRINTPAGE; FORWARD;
PROCEDURE PRINTLINE; FORWARD;
PROCEDURE PRINTNUM(WORD:INTEGER; BYTESIZE:BOOLEAN);  FORWARD;
PROCEDURE PUTBYTE(BYTE:BITE); FORWARD;
PROCEDURE SENDWORD(NUM:WORDSWAP; ASTRKCODE:INTEGER; JUSTPRINT:BOOLEAN); FORWARD;
PROCEDURE PUTRELWORD(WORD:INTEGER; BYTESIZE,WORDOFFSET:BOOLEAN); FORWARD;
PROCEDURE PUTWORD(WORD:INTEGER);  FORWARD;
PROCEDURE GETCHAR; FORWARD;
PROCEDURE LEX; FORWARD;
FUNCTION  EXPRESS(OPERANDREQUIRED:BOOLEAN):BOOLEAN; FORWARD;
FUNCTION  CHECKOPERAND(CKSPCSTK,CKABS,CKRANGE:BOOLEAN;LO,HI:INTEGER):BOOLEAN;
                                                              FORWARD;

{dummy segments necessary since compiled U-}
SEGMENT PROCEDURE DUMMY2;

  SEGMENT PROCEDURE DUMMY3;  BEGIN END;
  SEGMENT PROCEDURE DUMMY4;  BEGIN END;
  SEGMENT PROCEDURE DUMMY5;  BEGIN END;
  SEGMENT PROCEDURE DUMMY6;  BEGIN END;
  SEGMENT PROCEDURE DUMMY7;  BEGIN END;
  SEGMENT PROCEDURE DUMMY8;  BEGIN END;
  SEGMENT PROCEDURE DUMMY9;  BEGIN END;

BEGIN {only DUMMY2's name will require further compile-time space} END;


SEGMENT PROCEDURE INITIALIZE;
TYPE  OPREC=RECORD
         OPNAME:PACKNAME;
         OPVALUE:INTEGER;
         OPATRIB:ATRIBUTETYPE
      END;

VAR  OK:BOOLEAN;
     COUNT:INTEGER;
     ST1:STRING[1];
     OPFILENAME,LISTNAME:STRING;
     OPFILE:FILE OF OPREC;

PROCEDURE KEYTOKENSET;
BEGIN
  KWORDS[0] :='ALIGN   '; KTOKEN[0] :=ALIGN;
  KWORDS[1] :='ASCII   '; KTOKEN[1] :=ASCII;
  KWORDS[2] :='BLOCK   '; KTOKEN[2] :=BLOCK;
  KWORDS[3] :='BYTE    '; KTOKEN[3] :=BIGHT;
  KWORDS[4] :='CONST   '; KTOKEN[4] :=TCONST;
  KWORDS[5] :='EQU     '; KTOKEN[5] :=EQU;
  KWORDS[6] :='FUNC    '; KTOKEN[6] :=FUNC;
  KWORDS[7] :='PUBLIC  '; KTOKEN[7] :=PUBLIC;
  KWORDS[8] :='PRIVATE '; KTOKEN[8] :=PRIVATE;
  KWORDS[9] :='PROC    '; KTOKEN[9] :=PROC;
  KWORDS[10]:='WORD    '; KTOKEN[10]:=WORD;
  KWORDS[11]:='INTERP  '; KTOKEN[11]:=TINTERP;
  KWORDS[12]:='MACRO   '; KTOKEN[12]:=MACRODEF;
  KWORDS[13]:='ENDM    '; KTOKEN[13]:=MACROEND;
  KWORDS[14]:='IF      '; KTOKEN[14]:=CONDITION;
  KWORDS[15]:='ENDC    '; KTOKEN[15]:=CONDEND;
  KWORDS[16]:='ELSE    '; KTOKEN[16]:=TELSE;
  KWORDS[17]:='REF     '; KTOKEN[17]:=REF;
  KWORDS[18]:='DEF     '; KTOKEN[18]:=DEF;
  KWORDS[19]:='ORG     '; KTOKEN[19]:=ORG;
  KWORDS[20]:='INCLUDE '; KTOKEN[20]:=INCLUDE;
  KWORDS[21]:='LIST    '; KTOKEN[21]:=LIST;
  KWORDS[22]:='NOLIST  '; KTOKEN[22]:=NOLIST;
  KWORDS[23]:='ASECT   '; KTOKEN[23]:=ASECT;
  KWORDS[24]:='PSECT   '; KTOKEN[24]:=PSECT;
  KWORDS[25]:='TITLE   '; KTOKEN[25]:=TITLE;
  KWORDS[26]:='END     '; KTOKEN[26]:=TEND;
  KWORDS[27]:='PAGE    '; KTOKEN[27]:=TPAGE;
  KWORDS[28]:='MACROLIS'; KTOKEN[28]:=TMLISTON;
  KWORDS[29]:='NOMACROL'; KTOKEN[29]:=TMLISTOFF;
  KWORDS[30]:='PATCHLIS'; KTOKEN[30]:=TPLISTON;
  KWORDS[31]:='NOPATCHL'; KTOKEN[31]:=TPLISTOFF;
  KWORDS[32]:='ABSOLUTE'; KTOKEN[32]:=TABSOLUTE;
END;

PROCEDURE CHECKSEX;
TYPE    CHECKREC=RECORD CASE BOOLEAN OF
                TRUE:(INT:INTEGER);
                FALSE:(BYTE:PACKED ARRAY[0..1] OF CHAR)
              END;
VAR     CHECK:CHECKREC;
BEGIN
  CHECK.INT:=1;
  BYTESEX:=(ORD(CHECK.BYTE[1])=1);  {true if running on HIBYTEFIRST machine}
END;

PROCEDURE LEXINIT;
VAR  HASHA,HASHB:INTEGER;
     BYTEFLIP:BOOLEAN;
     FLIPATRIB:RECORD CASE BOOLEAN OF
         TRUE:(INT:INTEGER);
         FALSE:(ATRIB:ATRIBUTETYPE)
       END;
     ID:PACKNAME;
BEGIN
  FOR COUNT:=0 TO HASHTOP DO HASH[COUNT]:=NIL;
  KEYTOKENSET;
  BYTEFLIP:=(OPFILE^.OPVALUE<>1);
  GET(OPFILE);
  REPEAT
    ID:=OPFILE^.OPNAME;
    HASHA:=0; FOUND:=FALSE;
    FOR COUNT:=0 TO 7 DO
      BEGIN
        HASHA:=HASHA + HASHA; {left shift}
        HASHB:=ORD(ID[COUNT]);
        HASHA:=ORD((NOT ODD(HASHA) AND ODD(HASHB)) OR
                   (ODD(HASHA) AND NOT ODD(HASHB)));
      END;
    HASHB:=ORD(ODD(HASHA) AND ODD(HASHTOP)); {lo-order part}
    HASHA:=HASHA DIV HASHRANGE; {hi-order part}
    HASHA:=ORD((NOT ODD(HASHA) AND ODD(HASHB)) OR
               (ODD(HASHA) AND NOT ODD(HASHB))); {xor}
    HASHA:=ORD(ODD(HASHA) AND ODD(HASHTOP)); {lo-order part}
    SYM:=HASH[HASHA];
    WHILE (NOT FOUND) AND (SYM<>NIL) DO
      IF SYM^.NAME=ID THEN FOUND:=TRUE
        ELSE SYM:=SYM^.LINK;
    IF FOUND THEN WRITELN('Opcode declared twice=',ID)
      ELSE
        BEGIN
          NEW(SYM,DEFABS); {using DEFABS here is to save compile time space}
          SYM^.NAME:=ID;
          IF BYTEFLIP THEN
            BEGIN
              SYM^.VALUE:=SWAPBYTE(OPFILE^.OPVALUE);
              FLIPATRIB.INT:=SWAPBYTE(ORD(OPFILE^.OPATRIB));
              SYM^.ATTRIBUTE:=FLIPATRIB.ATRIB;
            END
          ELSE
            BEGIN
              SYM^.ATTRIBUTE:=OPFILE^.OPATRIB;
              SYM^.VALUE:=OPFILE^.OPVALUE;
            END;
          SYM^.LINK:=HASH[HASHA];
          HASH[HASHA]:=SYM;
          IF DEBUG THEN WRITELN(ID,HASHA:10);
        END;
    GET(OPFILE);
  UNTIL EOF(OPFILE) OR (OPFILE^.OPNAME[1]=CHR(0));
  CLOSE(OPFILE);
  PARMCHECK:=FALSE;
  CURRENTATRIB:=UNKNOWN;
  BLOCKNO:=2;
  ADVANCE:=TRUE;
  MCSTKINDEX:=0;
  SOURCE:=FILESOURCE;
  BLOCKPTR:=1024;  ENDOFPAGE:=0;
  LEXTOKEN:=ENDLINE;
  TEMPTOP:=0; TEMPBOTTOM:=0;  FILLCHAR(TEMPSTACK,SIZEOF(TEMPSTACK),0);
END;

PROCEDURE FILEINIT;
BEGIN
  (*$I-*)
  LINKNAME:=':LINKER.INFO';
  OPFILENAME:=CONCAT(ASMNAME,'.OPCODES');
  RESET(OPFILE,CONCAT('*',OPFILENAME));
  IF IORESULT<>0 THEN
    BEGIN
      RESET(OPFILE,CONCAT('#4:',OPFILENAME));
      IF IORESULT<>0 THEN
        BEGIN
          RESET(OPFILE,CONCAT('#5:',OPFILENAME));
          IF IORESULT<>0 THEN
            BEGIN
              RESET(OPFILE,CONCAT('#9:',OPFILENAME));
              IF IORESULT<>0 THEN
                BEGIN
                  RESET(OPFILE,CONCAT('#10:',OPFILENAME));
                  IF IORESULT<>0 THEN
                    BEGIN
                      RESET(OPFILE,CONCAT('#11:',OPFILENAME));
                      IF IORESULT<>0 THEN
                        BEGIN
                          RESET(OPFILE,CONCAT('#12:',OPFILENAME));
                          LINKNAME:=CONCAT('#12',LINKNAME);
                        END
                      ELSE LINKNAME:=CONCAT('#11',LINKNAME);
                    END
                  ELSE LINKNAME:=CONCAT('#10',LINKNAME);
                END
              ELSE LINKNAME:=CONCAT('#9',LINKNAME);
            END
          ELSE LINKNAME:=CONCAT('#5',LINKNAME);
        END
      ELSE LINKNAME:=CONCAT('#4',LINKNAME);
    END
  ELSE LINKNAME:=CONCAT('*',LINKNAME);
  IF IORESULT<>0 THEN
    BEGIN
      WRITELN(OPFILENAME,' not on any vol on line');
      UNITCLEAR(3);
      EXIT(TLA);
    END;
END;

BEGIN {Segment INITIALIZE}
  FILEINIT;
  FILLCHAR(BLANKLINE,SIZEOF(BLANKLINE),0);
  TEXTLINE:=BLANKLINE;
  CHECKSEX;
  WRITELN(ASMNAME,'   Assembler  ',RELEASENAME);
  FOR COUNT:=0 TO CODESIZE DO BLANKCODE[COUNT]:=' ';
  CODE:=BLANKCODE; CODECOUNT:=0; HEXCHAR:='0123456789ABCDEF';
  BUFFERPOS:=0; NUMERRORS:=0; MINSPACE:=32767;
  LINENUM:=0;  SPCIALSTKINDEX:=-1; PROCNUM:=0; LISTNUM:=0;
  IF LENGTH(USERINFO.WORKTITLE)=0 THEN
    FIRSTFNAME:=USERINFO.SYMTITLE
  ELSE
    FIRSTFNAME:=USERINFO.WORKTITLE;
  CURFNAME:=FIRSTFNAME;
  DISPLAY:=FALSE; LISTING:=FALSE;
  REPEAT
    WRITE('Output file for assembled listing: (<CR> for none)');
    READ(CH);
    IF CH=CHR(27) THEN EXIT(TLA)
    ELSE IF EOLN THEN LISTNAME:=''
    ELSE
      BEGIN
        READLN(LISTNAME);
        ST1:=' '; ST1[1]:=CH;
        LISTNAME:=CONCAT(ST1,LISTNAME);
      END;
    CONSOLE:=(LISTNAME='CONSOLE:') OR (LISTNAME='#1:');
    IF LISTNAME<>'' THEN OPENNEW(LISTFILE,LISTNAME);
    OK:=(IORESULT=0);
    IOCHECK(FALSE);
  UNTIL OK;
  DISPLAY:=(LISTNAME<>''); LISTING:=DISPLAY;
  (*$I+*)
  IF DISPLAY THEN MCLISTLEVEL:=0 ELSE MCLISTLEVEL:=-1;
  PATCHLIST:=TRUE;
  MACROLIST:=TRUE;
  JUMPINFO:=TRUE;
  FOR COUNT:=1 TO 9 DO WRITELN;
  NULLREL.TIPE:=NOTSET; NULLREL.TEMPLABEL:=0; NULLREL.SYM:=NIL;
  NULLREL.ATTRIBUTE:=UNKNOWN; NULLREL.OFFSETORVALUE:=0;
  RELOCATE:=NULLREL; NULLREL.UNDEF:=FALSE;
  MARK(HEAP); {To initialize MEMAVAIL}
  EXPRSSADVANCE:=TRUE;  NOTSTRING:=TRUE; DEFMCHOOK:=FALSE;
  ALTINPUT:=FALSE; SYMLAST:=FALSE; FROMPUTWORD:=FALSE;
  LC:=0; LASTLC:=0; LOWLC:=0; ALC:=0;
  CONDINDEX:=-1;
  PROCNAME:='        ';
  PAGENO:=0;
  TITLELINE:=' ';
  IF DISPLAY THEN
    BEGIN
      WRITELN(LISTFILE,'PAGE - ',PAGENO:3);
      PAGENO:=PAGENO + 1;
    END;
  (*$I-*)
  REWRITE(SCRATCH,LINKNAME); LINKEND:=0;
  IOCHECK(TRUE);
  (*$I+*)
  NEW(SYM,UNKNOWN); {extra record on heap to garbage}
  LEXINIT;
  LFCONSOLE;
  CODESECTION:=P;
END;

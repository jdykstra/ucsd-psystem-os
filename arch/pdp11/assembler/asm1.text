(*
 * UCSD PASCAL - Version I.5
 * Copyright (C) 1978, 1979 Regents of the University of California
 * All Rights Reserved
 *
 * Permission to use, copy, modify and distribute any part of UCSD
 * PASCAL solely authored by UC authors before June 1, 1979 for
 * educational, research and non-profit purposes, without fee, and
 * without a written agreement is hereby granted, provided that the
 * above copyright notice, this paragraph and the following three
 * paragraphs appear in all copies.
 *
 * Those desiring to incorporate UCSD PASCAL into commercial products or
 * use for commercial purposes should contact the Technology Transfer &
 * Intellectual Property Services, University of California, San Diego,
 * 9500 Gilman Drive, Mail Code 0910, La Jolla, CA 92093-0910,
 * Ph: (858) 534-5815, Fax: (858) 534-7345, E-Mail: invent@ucsd.edu.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
 * INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF UCSD PASCAL, EVEN IF
 * THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 * THE SOFTWARE PROVIDED HEREIN IS ON AN "AS IS" BASIS, AND THE UNIVERSITY
 * OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS. THE UNIVERSITY OF CALIFORNIA
 * MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES OF ANY KIND,
 * EITHER IMPLIED OR EXPRESS, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR
 * THAT THE USE OF UCSD PASCAL WILL NOT INFRINGE ANY PATENT, TRADEMARK OR
 * OTHER RIGHTS.
 *
 * Case Number: SD1991-807 (2006)
 * http://invent.ucsd.edu/technology/cases/1995-prior/SD1991-807.shtml
 *)

 TOKENS=(EQUAL,NOTEQUAL,BITWISEOR,EXCLUSIVEOR,DIVIDE,MODULO,ONESCOMPLEMENT,TNOT,
        OPENPAREN,CLOSEPAREN,OPENBRACKET,CLOSEBRACKET,OPNBRACE,CLSBRACE,
        COMMA,OPNBROKEN,CLSBROKEN,QUERY,PLUS,MINUS,
        ASTERISK,AMPERSAND,ATSIGN,COLON,NUMBERSIGN,AUTOINCR,AUTODECR,LOCCTR,
        FIRSTOPCODE,
        REF,DEF,OP1,OP2,OP3,OP4,OP5,OP6,OP7,OP8,OP9,OP10,OP11,OP12,OP13,
        OP14,OP15,OP16,OP17,OP18,OP19,OP20,ALIGN,
        TEOF,BLOCK,WORD,BIGHT,ENDLINE,TMOD,PROC,FUNC,CONDEND,TELSE,ORG,
        ASCII,MACRODEF,CONDITION,EQU,PUBLIC,PRIVATE,TCONST,
        LIST,NOLIST,ASECT,PSECT,TEND,TPAGE,TITLE,
        LASTOPCODE,
        INCLUDE,TLABEL,LOCLABEL,TSTRING,CONSTANT,TIDENTIFIER,STARTFILE,
        MACROEND,EXPAND,TNULL);
     CODETYPE=(A,P);
     SOURCETYPE=(MACROSOURCE,PARMSOURCE,FILESOURCE);
     ATRIBUTETYPE=(DEFABS,PROCS,
            OPS1,OPS2,OPS3,OPS4,OPS5,OPS6,OPS7,OPS8,OPS9,OPS10,OPS11,
            OPS12,OPS13,OPS14,OPS15,OPS16,OPS17,OPS18,OPS19,OPS20,
            DEFRP,DEFREG,DEFCC,DEFIR,
            PUBLICS,CONSTS,PRIVATES,REFS,DEFS,FUNCS,ABS,LABELS,UNKNOWN,MACROS);
     MACROPTR=^MACROTYPE;
     MACROTYPE=PACKED ARRAY[0..MACROSIZE] OF CHAR;
     JTABPTR=^JTAB;
     JTAB=RECORD               {Used for linkinfo references}
        PCOFFSET:INTEGER;
        LAST:JTABPTR
      END;
     BKLABELPTR=^BACKLABEL;
     SYMTABLEPTR=^SYMBOLTABLE;
     SYMBOLTABLE=RECORD        {Symboltable entry}
        NAME:PACKNAME;
        LINK:SYMTABLEPTR;
        CASE ATTRIBUTE:ATRIBUTETYPE OF
          {OPS1,OPS2,OPS3,OPS4,OPS5,OPS6,OPS7,OPS8,OPS9,OPS10,
          OPS11,OPS12,OPS13,OPS14,OPS15,OPS16,OPS17,OPS18,OPS19,OPS20,
          ABS,DEFABS,DEFRP,DEFREG,DEFCC,DEFIR,LABELS,}
                            UNKNOWN:(OFFSETORVALUE:INTEGER;
                                     FWDREF:BKLABELPTR);
                             MACROS:(MACRO:MACROPTR;
                                    EXPANDMCRO:BOOLEAN);
                               DEFS:(PROCNUM,CODEOFFSET:INTEGER;
                                     DEFFWDREF:BKLABELPTR);
       PUBLICS,PRIVATES,REFS,CONSTS:(NREFS,NWORDS:INTEGER;
                                     LINKOFFSET:JTABPTR);
                        PROCS,FUNCS:(FUNCNUM,NPARAMS:INTEGER)
       END;
     TEMPTABLE=RECORD            {Temporary table entry}
          TEMPNAME:PACKNAME;
          DEFOFFSET:INTEGER;
          FWDREF:BKLABELPTR;
          TEMPATRIB:ATRIBUTETYPE
       END;
     RELTYPE=(LLREL,LABELREL,LCREL,NOTSET);
     RESULTREC=RECORD            {expression evaluator result record}
          ATTRIBUTE:ATRIBUTETYPE;
          OFFSETORVALUE:INTEGER;
       END;
     RELREC=RECORD               {current expression's relocation info}
          TIPE:RELTYPE;
          OFFSETORVALUE,TEMPLABEL:INTEGER;
          ATTRIBUTE:ATRIBUTETYPE;
          SYM:SYMTABLEPTR
       END;
     BACKLABEL=PACKED RECORD     {forward reference record}
          WORDLC,BYTESIZE:BOOLEAN;
          OFFSET,LC,VALUE:INTEGER;
          NEXT:BKLABELPTR
       END;
     JTABREC=ARRAY[0..6] OF INTEGER;     {for storage of relocation info}
     BUFFERTYPE=PACKED ARRAY[0..511] OF BITE;
     SCRATCHREC=RECORD            {scratch file for temporary storage}
          CLASS:INTEGER;
          CASE BOOLEAN OF
               TRUE:(JUMPS:JTABREC);
              FALSE:(FWDREF:BACKLABEL)
     END;

 {----------------------------------------------------------------------}

 VAR SYM:SYMTABLEPTR;      {pointer to current symboltable entry}
     LEXTOKEN:TOKENS;      {current token returned by LEX}
     OUTBLKNO,             {next output block #}
     TEXTINDEX,            {index into TEXTLINE, containing line of source text}
     MACROINDEX,           {index into macro source sitting on heap}
     SPCIALSTKINDEX,       {index into stack of outstanding special symbols}
     CODECOUNT:INTEGER;    {index into array containing current line's code}
     OPBYTE:BYTESWAP;      {used exclusively by ZOP1 - ZOP20}
     CH:CHAR;
     DISPLAY:BOOLEAN;      {currently displaying output?}
     FULLLABEL:BKLABELPTR; {forward referenced labels still unresolved}
     RESULT:RESULTREC;     {result of last call to expression evaluator}

     BUFBOTTOM,            {start of BUFFER relative to start of output file}
     BUFFERPOS,            {next output byte relative to start of BUFFER}
     BUFFERTOP,            {next output byte relative to start of file}
     MAXBUFTOP,            {maximum BUFFERTOP}
     OUTBLKTOP,            {next block after current end of output file}
     PROCSTART,            {start of procedure relative to start of file}
     JCOUNT1,JCOUNT2,JCOUNT3, {indexes for relocation records JTABREC's}
     TEMPTOP,TEMPLABEL,
     BLOCKPTR,BNUM,BLOCKNO,ALTBLOCNO,ALTBLOCPTR,
     PROCNUM,SEGSIZE,PAGENO,
     LINENUM,LISTNUM,
     NUMERRORS,
     OPVAL,CONSTVAL,
     PARMPTR,MCSTKINDEX,LINKEND,SCRATCHEND,CONDINDEX,
     LC,ALC,LASTLC,LOWLC                                 :INTEGER;

     SYMLAST,FOUND,CONSOLE,STARTLINE,FROMPUTWORD,NOTSTRING,LISTING,JUMPINFO,
     ADVANCE,EXPANDMACRO,PARMCHECK,ALTINPUT,EXPRSSADVANCE,DEFMCHOOK  :BOOLEAN;
     MCPTR:MACROPTR;
     BUFFER:^BUFFERTYPE;   {buffer for output code in core}
     TAB:CHAR;
     LISTFILE:INTERACTIVE;
     TITLELINE,STRVAL,CURFNAME,FIRSTFNAME:STRING;
     TEXTLINE,BLANKLINE:PACKED ARRAY[0..79] OF CHAR;

     RELOCATE,OPERAND1,OPERAND2,OPERAND3,NULLREL:RELREC;
     NEXTJP:JTABPTR;
     JUMP1,JUMP2,JUMP3:JTABREC;
     FREELABEL:BKLABELPTR;

     CURRENTATRIB:ATRIBUTETYPE;
     SOURCE:SOURCETYPE;
     CODESECTION:CODETYPE;
     MACROSTACK:ARRAY[0..5] OF MACROPTR;
     PARMSTACK,MCINDEX:ARRAY[0..5] OF INTEGER;
     SPECIALSTK:ARRAY[0..5] OF TOKENS;
     TEMP:ARRAY[0..20] OF TEMPTABLE;
     HASH,HASHRES:ARRAY[0..HASHTOP] OF SYMTABLEPTR;
     LASTSYM:SYMTABLEPTR;

     ALTFILE:FILE;
     SCRATCH:FILE OF SCRATCHREC;

     KWORDS:ARRAY[0..NUMKWORDS] OF PACKNAME;
     KTOKEN:ARRAY [0..NUMKWORDS] OF TOKENS;
     XBLOCK:PACKED ARRAY[0..1023] OF CHAR;
     CONSTID,HEXCHAR:PACKED ARRAY[0..15] OF CHAR;
     CODE,BLANKCODE:PACKED ARRAY[0..CODESIZE] OF CHAR;
     HEAP:^INTEGER;
     SEGNAME,PROCNAME:PACKNAME;
     PROCTABLE:ARRAY[0..MAXPROC] OF INTEGER;


 PROCEDURE ERROR(ERRORNUM:INTEGER); FORWARD;
 PROCEDURE PATCHCODE(FWDREF:BACKLABEL; BUFINDEX:INTEGER); FORWARD;
 PROCEDURE IOCHECK(QUIT:BOOLEAN); FORWARD;
 PROCEDURE LLCHECK; FORWARD;
 PROCEDURE PRINTPAGE; FORWARD;
 PROCEDURE PRINTLINE; FORWARD;
 PROCEDURE PRINTNUM(WORD:INTEGER; BYTESIZE:BOOLEAN);  FORWARD;
 PROCEDURE PUTBYTE(BYTE:BITE); FORWARD;
 PROCEDURE PUTRELWORD(WORD:INTEGER; BYTESIZE,WORDOFFSET:BOOLEAN); FORWARD;
 PROCEDURE PUTWORD(WORD:INTEGER);  FORWARD;
 PROCEDURE GETCHAR; FORWARD;
 PROCEDURE LEX; FORWARD;
 FUNCTION  EXPRESS(OPERANDREQUIRED:BOOLEAN):BOOLEAN; FORWARD;
 FUNCTION  CHECKOPERAND(CKSPCSTK,CKABS,CKRANGE:BOOLEAN;LO,HI:INTEGER):BOOLEAN;
                                                               FORWARD;

 {dummy segments necessary since compiled U-}
 SEGMENT PROCEDURE DUMMY2;  BEGIN END;
 SEGMENT PROCEDURE DUMMY3;  BEGIN END;
 SEGMENT PROCEDURE DUMMY4;  BEGIN END;
 SEGMENT PROCEDURE DUMMY5;  BEGIN END;
 SEGMENT PROCEDURE DUMMY6;  BEGIN END;
 SEGMENT PROCEDURE DUMMY7;  BEGIN END;
 SEGMENT PROCEDURE DUMMY8;  BEGIN END;
 SEGMENT PROCEDURE DUMMY9;  BEGIN END;


 SEGMENT PROCEDURE INITIALIZE;
 TYPE  OPREC=RECORD
          OPNAME:PACKNAME;
          OPVALUE:INTEGER;
          OPATRIB:ATRIBUTETYPE
       END;

 VAR  OK:BOOLEAN;
      COUNT:INTEGER;
      OPFILENAME,LISTNAME:STRING;
      OPFILE:FILE OF OPREC;

 PROCEDURE KEYTOKENSET;
 BEGIN
   KWORDS[0] :='ALIGN   '; KTOKEN[0] :=ALIGN;
   KWORDS[1] :='ASCII   '; KTOKEN[1] :=ASCII;
   KWORDS[2] :='BLOCK   '; KTOKEN[2] :=BLOCK;
   KWORDS[3] :='BYTE    '; KTOKEN[3] :=BIGHT;
   KWORDS[4] :='CONST   '; KTOKEN[4] :=TCONST;
   KWORDS[5] :='EQU     '; KTOKEN[5] :=EQU;
   KWORDS[6] :='FUNC    '; KTOKEN[6] :=FUNC;
   KWORDS[7] :='PUBLIC  '; KTOKEN[7] :=PUBLIC;
   KWORDS[8] :='PRIVATE '; KTOKEN[8] :=PRIVATE;
   KWORDS[9] :='PROC    '; KTOKEN[9] :=PROC;
   KWORDS[10]:='WORD    '; KTOKEN[10]:=WORD;
   KWORDS[11]:='EXPAND  '; KTOKEN[11]:=EXPAND;
   KWORDS[12]:='MACRO   '; KTOKEN[12]:=MACRODEF;
   KWORDS[13]:='ENDM    '; KTOKEN[13]:=MACROEND;
   KWORDS[14]:='IF      '; KTOKEN[14]:=CONDITION;
   KWORDS[15]:='ENDC    '; KTOKEN[15]:=CONDEND;
   KWORDS[16]:='ELSE    '; KTOKEN[16]:=TELSE;
   KWORDS[17]:='REF     '; KTOKEN[17]:=REF;
   KWORDS[18]:='DEF     '; KTOKEN[18]:=DEF;
   KWORDS[19]:='ORG     '; KTOKEN[19]:=ORG;
   KWORDS[20]:='INCLUDE '; KTOKEN[20]:=INCLUDE;
   KWORDS[21]:='LIST    '; KTOKEN[21]:=LIST;
   KWORDS[22]:='NOLIST  '; KTOKEN[22]:=NOLIST;
   KWORDS[23]:='ASECT   '; KTOKEN[23]:=ASECT;
   KWORDS[24]:='PSECT   '; KTOKEN[24]:=PSECT;
   KWORDS[25]:='TITLE   '; KTOKEN[25]:=TITLE;
   KWORDS[26]:='END     '; KTOKEN[26]:=TEND;
   KWORDS[27]:='PAGE    '; KTOKEN[27]:=TPAGE;
 END;

 PROCEDURE LEXINIT;
 VAR  HASHA,HASHB:INTEGER;
      ID:PACKNAME;
 BEGIN
   FOR COUNT:=0 TO HASHTOP DO HASH[COUNT]:=NIL;
   KEYTOKENSET;
   REPEAT
     ID:=OPFILE^.OPNAME;
     HASHA:=0; FOUND:=FALSE;
     FOR COUNT:=0 TO 7 DO
       BEGIN
         HASHA:=HASHA + HASHA; {left shift}
         HASHB:=ORD(ID[COUNT]);
         HASHA:=ORD((NOT ODD(HASHA) AND ODD(HASHB)) OR
                    (ODD(HASHA) AND NOT ODD(HASHB)));
       END;

     HASHB:=HASHA MOD HASHRANGE; {lo-order part}
     HASHA:=HASHA DIV HASHRANGE; {hi-order part}
     HASHA:=ORD((NOT ODD(HASHA) AND ODD(HASHB)) OR
                (ODD(HASHA) AND NOT ODD(HASHB))); {xor}
     HASHA:=HASHA MOD HASHRANGE;
     SYM:=HASH[HASHA];
     WHILE (NOT FOUND) AND (SYM<>NIL) DO
       IF SYM^.NAME=ID THEN FOUND:=TRUE
         ELSE SYM:=SYM^.LINK;
     IF FOUND THEN WRITELN('Opcode declared twice=',ID)
       ELSE
         BEGIN
           NEW(SYM,UNKNOWN); {using UNKNOWN here is to save compile time space}
           SYM^.NAME:=ID; SYM^.ATTRIBUTE:=OPFILE^.OPATRIB;
           SYM^.OFFSETORVALUE:=OPFILE^.OPVALUE;
           SYM^.LINK:=HASH[HASHA];
           HASH[HASHA]:=SYM;
           IF DEBUG THEN WRITELN(ID,HASHA:10);
         END;
     GET(OPFILE);
   UNTIL EOF(OPFILE);
   EXPANDMACRO:=TRUE;
   PARMCHECK:=FALSE;
   CURRENTATRIB:=UNKNOWN;
   BLOCKNO:=2;
   ADVANCE:=TRUE;
   MCSTKINDEX:=0;
   SOURCE:=FILESOURCE;
   BLOCKPTR:=1024;
   LEXTOKEN:=ENDLINE;
   TEMPTOP:=0;
 END;

 BEGIN {Segment INITIALIZE}
   (*$I-*)
   OPFILENAME:=CONCAT(ASMNAME,'.OPCODES');
   OPFILENAME:=CONCAT('*',OPFILENAME);
   RESET(OPFILE,OPFILENAME);
   IF IORESULT<>0 THEN
     BEGIN
       WRITELN(OPFILENAME,' not on vol');
       UNITCLEAR(3);
       EXIT(TLA);
     END;
   FOR COUNT:=0 TO 79 DO BLANKLINE[COUNT]:=CHR(0);
   TEXTLINE:=BLANKLINE;
   WRITELN(ASMNAME,'   Assembler  ',RELEASENAME);
   FOR COUNT:=0 TO CODESIZE DO BLANKCODE[COUNT]:=' ';
   CODE:=BLANKCODE; CODECOUNT:=0; HEXCHAR:='0123456789ABCDEF';
   BUFFERPOS:=0; NUMERRORS:=0;
   TAB:=CHR(9);
   LINENUM:=0;  SPCIALSTKINDEX:=-1; PROCNUM:=0; LISTNUM:=0;
   IF LENGTH(USERINFO.WORKTITLE)=0 THEN
     FIRSTFNAME:=USERINFO.SYMTITLE
   ELSE
     FIRSTFNAME:=USERINFO.WORKTITLE;
   CURFNAME:=FIRSTFNAME;
   REPEAT
     WRITE('Output file for assembled listing: (<CR> for none)');
     READLN(LISTNAME);
     DISPLAY:=(LISTNAME<>'');  LISTING:=DISPLAY;
     CONSOLE:=(LISTNAME='CONSOLE:') OR (LISTNAME='#1:');
     IF DISPLAY THEN
       IF CONSOLE THEN
         OPENNEW(LISTFILE,'CONSOLE:')
       ELSE
         OPENNEW(LISTFILE,CONCAT(LISTNAME,'.TEXT[*]'));
     OK:=(IORESULT=0);
     IOCHECK(FALSE);
   UNTIL OK;
   (*$I+*)
   IF NOT RELEASEVERSION THEN
     BEGIN
       WRITELN('Relocation info at file end?');
       READ(KEYBOARD,CH);
       JUMPINFO:=(CH='Y') OR (CH='y');
     END
   ELSE JUMPINFO:=TRUE;
   FOR COUNT:=1 TO 9 DO WRITELN;
   NULLREL.TIPE:=NOTSET; NULLREL.TEMPLABEL:=0; NULLREL.SYM:=NIL;
   NULLREL.ATTRIBUTE:=UNKNOWN; NULLREL.OFFSETORVALUE:=0;
   RELOCATE:=NULLREL;
   MARK(HEAP); {To initialize MEMAVAIL}
   EXPRSSADVANCE:=TRUE;  NOTSTRING:=TRUE; DEFMCHOOK:=FALSE;
   ALTINPUT:=FALSE; SYMLAST:=FALSE; FROMPUTWORD:=FALSE;
   LC:=0; LASTLC:=0; LOWLC:=0; ALC:=0;
   CONDINDEX:=-1;
   PROCNAME:='        ';
   PAGENO:=0;
   TITLELINE:=' ';
   IF DISPLAY THEN
     BEGIN
       WRITELN(LISTFILE,'PAGE - ',PAGENO:3);
       PAGENO:=PAGENO + 1;
     END;
   (*$I-*)
   REWRITE(SCRATCH,'*LINKER.INFO'); LINKEND:=0;
   IOCHECK(TRUE);
   (*$I+*)
   NEW(SYM,UNKNOWN); {extra record on heap to garbage}
   LEXINIT;
   IF NOT (CONSOLE AND DISPLAY) THEN
     BEGIN
       WRITELN;
       WRITE('<   0>');
     END;
   CODESECTION:=P;
 END;
